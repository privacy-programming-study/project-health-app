(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms'), require('@ionic/angular'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ionic4-auto-complete', ['exports', '@angular/core', '@angular/common', '@angular/forms', '@ionic/angular', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ionic4-auto-complete'] = {}, global.ng.core, global.ng.common, global.ng.forms, global['@ionic/angular'], global.rxjs, global.rxjs.operators));
}(this, (function (exports, core, common, forms, angular, rxjs, operators) { 'use strict';

    var AutoCompleteOptions = /** @class */ (function () {
        function AutoCompleteOptions() {
            this.animated = false;
            this.color = null;
            this.autocomplete = 'off';
            this.autocorrect = 'off';
            this.cancelButtonIcon = 'arrow-round-back';
            this.cancelButtonText = 'Cancel';
            this.clearIcon = 'close-circle';
            this.clearInput = false;
            this.clearOnEdit = false;
            this.debounce = 250;
            this.mode = 'md';
            this.noItems = 'No items found.';
            this.placeholder = 'Search';
            this.searchIcon = 'search';
            this.showCancelButton = false;
            this.spellcheck = 'off';
            this.type = 'search';
        }
        return AutoCompleteOptions;
    }());

    var AutoCompleteStyles = /** @class */ (function () {
        function AutoCompleteStyles() {
            this.list = {};
            this.listItem = {};
            this.searchbar = {};
        }
        return AutoCompleteStyles;
    }());

    var AutoCompleteComponent = /** @class */ (function () {
        /**
         * Create a new instance
         */
        function AutoCompleteComponent() {
            this.autocompleteOptions = new AutoCompleteOptions();
            this.hasFocus = false;
            this.isLoading = false;
            this.focusedOption = -1;
            this.showSuggestions = false;
            this.onTouchedCallback = false;
            this.onChangeCallback = false;
            this.showListChanged = false;
            this.alwaysShowList = false;
            this.autoFocusSuggestion = true;
            this.clearInvalidInput = true;
            this.disabled = false;
            this.exclude = [];
            this.frontIcon = false;
            this.hideListOnSelection = true;
            this.label = '';
            this.labelPosition = 'fixed';
            this.location = 'auto';
            this.maxResults = 8;
            this.maxSelected = null;
            this.multi = false;
            this.name = '';
            this.removeButtonClasses = '';
            this.removeButtonColor = 'primary';
            this.removeButtonIcon = 'close-circle';
            this.removeButtonSlot = 'end';
            this.removeDuplicateSuggestions = true;
            this.selectOnTabOut = true;
            this.styles = new AutoCompleteStyles;
            this.useIonInput = false;
            this.autoBlur = new core.EventEmitter();
            this.autoFocus = new core.EventEmitter();
            this.blur = new core.EventEmitter();
            this.focus = new core.EventEmitter();
            this.ionAutoInput = new core.EventEmitter();
            this.itemsChange = new core.EventEmitter();
            this.itemsCleared = new core.EventEmitter();
            this.itemsHidden = new core.EventEmitter();
            this.itemRemoved = new core.EventEmitter();
            this.itemSelected = new core.EventEmitter();
            this.itemsShown = new core.EventEmitter();
            this.modelChange = new core.EventEmitter();
            this.keyword = '';
            this.suggestions = [];
        }
        Object.defineProperty(AutoCompleteComponent.prototype, "dataProvider", {
            set: function (provider) {
                if (typeof provider !== 'undefined') {
                    this.provider = provider;
                    if (typeof this.selected !== 'undefined') {
                        this.keyword = this.getLabel(this.selected);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutoCompleteComponent.prototype, "eager", {
            set: function (eager) {
                if (eager) {
                    this.getItems(null, false);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutoCompleteComponent.prototype, "options", {
            set: function (options) {
                this.autocompleteOptions = new AutoCompleteOptions();
                var keys = Object.keys(options);
                var keysLength = keys.length;
                for (var i = 0; i < keysLength; i++) {
                    var key = keys[i];
                    if (typeof options[key] !== 'undefined') {
                        this.autocompleteOptions[key] = options[key];
                    }
                }
                if (typeof this.selected === 'undefined') {
                    if (typeof this.autocompleteOptions.value !== 'undefined') {
                        this.selected = this.autocompleteOptions.value;
                    }
                    else {
                        if (this.multi) {
                            this.selected = [];
                        }
                        else {
                            this.selected = null;
                        }
                    }
                    this.keyword = this.getLabel(this.selected);
                }
                if (this.autocompleteOptions.autocomplete) {
                    this.autocomplete = this.autocompleteOptions.autocomplete;
                }
                else {
                    this.autocomplete = 'off';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutoCompleteComponent.prototype, "model", {
            get: function () {
                var model = this.selected;
                if (!this.multi && typeof this.selected.length !== 'undefined') {
                    if (this.selected.length === 0) {
                        model = null;
                    }
                    else {
                        model = this.selected[0];
                    }
                }
                return model;
            },
            set: function (selected) {
                this.selected = selected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutoCompleteComponent.prototype, "showList", {
            get: function () {
                return this.showSuggestions;
            },
            set: function (value) {
                if (typeof value === 'undefined') {
                    return;
                }
                if (this.showSuggestions === value) {
                    return;
                }
                this.showSuggestions = value === true;
                this.showListChanged = true;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Handle document click
         *
         * @param event
         *
         * @private
         */
        AutoCompleteComponent.prototype.documentClickHandler = function (event) {
            if (this.isEventWithinElement(this.searchbarElem, event)
                || this.isEventWithinElement(this.inputElem, event)
                || (this.isEventWithinElement(this.itemList, event))) {
                this.setSuggestions(this.suggestions);
            }
            else {
                this.hideItemList();
            }
        };
        AutoCompleteComponent.prototype.ngAfterViewChecked = function () {
            if (this.showListChanged) {
                this.showListChanged = false;
                this.showSuggestions ? this.itemsShown.emit() : this.itemsHidden.emit();
            }
        };
        AutoCompleteComponent.prototype.ngDoCheck = function () {
            if (!this.hasFocus) {
                if (this.clearInvalidInput && (this.selected === null || this.multi)) {
                    if (this.keyword !== '') {
                        this.keyword = '';
                    }
                    if (this.inputElem && this.inputElem.nativeElement) {
                        if (this.inputElem.nativeElement.children && this.inputElem.nativeElement.children.length !== 0) {
                            if (this.inputElem.nativeElement.children[0].children && this.inputElem.nativeElement.children[0].children.length !== 0) {
                                if (this.inputElem.nativeElement.children[0].children[0].value) {
                                    this.inputElem.nativeElement.children[0].children[0].value = '';
                                }
                            }
                        }
                    }
                    if (this.searchbarElem && this.searchbarElem.nativeElement) {
                        if (this.searchbarElem.nativeElement.children && this.searchbarElem.nativeElement.children.length !== 0) {
                            if (this.searchbarElem.nativeElement.children[0].children) {
                                if (this.searchbarElem.nativeElement.children[0].children.length !== 0) {
                                    if (this.searchbarElem.nativeElement.children[0].children[0].value) {
                                        this.searchbarElem.nativeElement.children[0].children[0].value = '';
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        /**
         * Get element's position on screen
         *
         * @param el
         *
         * @private
         */
        AutoCompleteComponent.prototype._getPosition = function (el) {
            var xPos = 0;
            var yPos = 0;
            while (el) {
                if (el.tagName === 'BODY') {
                    var xScroll = el.scrollLeft || document.documentElement.scrollLeft;
                    var yScroll = el.scrollTop || document.documentElement.scrollTop;
                    xPos += (el.offsetLeft - xScroll + el.clientLeft);
                    yPos += (el.offsetTop - yScroll + el.clientTop);
                }
                else {
                    xPos += (el.offsetLeft - el.scrollLeft + el.clientLeft);
                    yPos += (el.offsetTop - el.scrollTop + el.clientTop);
                }
                el = el.offsetParent;
            }
            return {
                x: xPos,
                y: yPos
            };
        };
        AutoCompleteComponent.prototype.isEventWithinElement = function (elementOrTemplate, event) {
            if (typeof elementOrTemplate === 'undefined') {
                return false;
            }
            var element;
            if (elementOrTemplate instanceof core.TemplateRef) {
                element = elementOrTemplate.elementRef;
            }
            else if (elementOrTemplate instanceof core.ViewContainerRef) {
                element = elementOrTemplate.element.nativeElement;
            }
            else {
                element = elementOrTemplate;
            }
            return element
                && element.nativeElement
                && element.nativeElement.contains(event.target);
        };
        /**
         * Get value from form
         *
         * @param selection
         *
         * @private
         */
        AutoCompleteComponent.prototype.getFormValue = function (selection) {
            if (typeof this.provider === 'undefined') {
                return null;
            }
            if (selection == null || typeof this.provider === 'function') {
                return null;
            }
            var attr = this.provider.formValueAttribute == null ?
                this.provider.labelAttribute : this.provider.formValueAttribute;
            if (typeof selection === 'object' && attr) {
                return selection[attr];
            }
            return selection;
        };
        AutoCompleteComponent.prototype.clickClear = function () {
            this.clearValue();
            this.hideItemList();
            this.itemsCleared.emit(true);
        };
        /**
         * Clear current input value
         */
        AutoCompleteComponent.prototype.clearValue = function () {
            this.keyword = '';
            this.selection = null;
            this.formValue = null;
            if (this.focusedOption > 0) {
                this.focusedOption = this.focusedOption - 1;
            }
            return;
        };
        /**
         * Get items for auto-complete
         *
         * @param event
         * @param show
         */
        AutoCompleteComponent.prototype.getItems = function (event, show) {
            var _this = this;
            this.isLoading = true;
            if (this.promise) {
                clearTimeout(this.promise);
            }
            this.promise = setTimeout(function () {
                if (event) {
                    _this.keyword = event.detail.target.value;
                }
                var result;
                if (_this.showResultsFirst && _this.keyword.trim() === '') {
                    _this.keyword = '';
                }
                if (typeof _this.provider === 'function') {
                    result = _this.provider(_this.keyword);
                    _this.setSuggestions(result, show);
                    _this.isLoading = false;
                }
                else {
                    result = _this.provider.getResults(_this.keyword);
                    if (result instanceof rxjs.Subject) {
                        result = result.asObservable();
                    }
                    else if (result instanceof Promise) {
                        result = rxjs.from(result);
                    }
                    if (result instanceof rxjs.Observable) {
                        result.pipe(operators.finalize(function () {
                            _this.isLoading = false;
                        })).subscribe(function (results) {
                            _this.setSuggestions(results, show);
                        }, function (error) { return console.error(error); });
                    }
                    else {
                        _this.setSuggestions(result, show);
                        _this.isLoading = false;
                    }
                }
                _this.ionAutoInput.emit(_this.keyword);
            }, this.autocompleteOptions.debounce);
        };
        /**
         * Get an item's label
         *
         * @param selection
         */
        AutoCompleteComponent.prototype.getLabel = function (selection) {
            if (typeof this.provider === 'undefined') {
                return '';
            }
            if (selection == null || typeof this.provider === 'function') {
                return '';
            }
            var attr = this.provider.formValueAttribute == null ?
                this.provider.labelAttribute : this.provider.formValueAttribute;
            var value = selection;
            if (this.provider.getItemLabel) {
                value = this.provider.getItemLabel(value);
            }
            if (!this.multi && typeof value !== 'undefined' && Object.prototype.toString.call(value) === '[object Array]') {
                if (value.length === 0) {
                    return '';
                }
                else {
                    value = value[0];
                }
            }
            if (typeof value === 'object' && attr) {
                return value[attr] || '';
            }
            return value || '';
        };
        /**
         * Get menu style
         */
        AutoCompleteComponent.prototype.listStyles = function () {
            var listLocationStyles = this.listLocationStyles();
            return Object.assign(Object.assign({}, listLocationStyles), this.styles.list);
        };
        AutoCompleteComponent.prototype.listLocationStyles = function () {
            var location = this.location;
            if (this.location === 'auto') {
                var elementY = this._getPosition(this.searchbarElem.nativeElement).y;
                var windowY = window.innerHeight;
                if (elementY > windowY - elementY) {
                    location = 'top';
                }
                else {
                    location = 'bottom';
                }
            }
            if (location === 'bottom') {
                return {};
            }
            else {
                return {
                    'bottom': '37px'
                };
            }
        };
        /**
         * Handles tab key press.
         * If `selectOnTabOut` is `true`, will select currently focused item
         *
         * @param event
         */
        AutoCompleteComponent.prototype.handleTabOut = function (event) {
            if (this.selectOnTabOut && this.suggestions.length !== 0) {
                if (this.focusedOption !== -1) {
                    this.selectItem(this.suggestions[this.focusedOption]);
                }
                else {
                    this.hideItemList();
                }
            }
            else {
                this.hideItemList();
            }
            this.onBlur(event);
        };
        /**
         * Handle tap
         *
         * @param event
         */
        AutoCompleteComponent.prototype.handleTap = function (event) {
            if (this.showResultsFirst || this.keyword.length > 0) {
                this.getItems();
            }
        };
        /**
         * Handle tap when selecting an item
         *
         * @param $event
         * @param suggestion
         */
        AutoCompleteComponent.prototype.handleSelectTap = function ($event, suggestion) {
            if (typeof suggestion !== 'undefined') {
                this.selectItem(suggestion);
                if ($event.srcEvent) {
                    if ($event.srcEvent.stopPropagation) {
                        $event.srcEvent.stopPropagation();
                    }
                    if ($event.srcEvent.preventDefault) {
                        $event.srcEvent.preventDefault();
                    }
                }
                else if ($event.preventDefault) {
                    $event.preventDefault();
                }
            }
            return false;
        };
        /**
         * Hide item list
         */
        AutoCompleteComponent.prototype.hideItemList = function () {
            if (this.showSuggestions === false && this.alwaysShowList === false) {
                this.showListChanged = true;
            }
            this.showSuggestions = this.alwaysShowList;
            this.focusedOption = -1;
        };
        AutoCompleteComponent.prototype.highlightItem = function (direction) {
            if (this.showSuggestions === false) {
                this.showItemList();
            }
            var max = this.suggestions.length - 1;
            if (max > this.maxResults) {
                max = this.maxResults - 1;
            }
            if (direction < 0) {
                if (this.focusedOption === -1 || this.focusedOption === max) {
                    this.focusedOption = 0;
                }
                else {
                    this.focusedOption++;
                }
            }
            else if (direction > 0) {
                if (this.focusedOption === -1 || this.focusedOption === 0) {
                    this.focusedOption = max;
                }
                else {
                    this.focusedOption--;
                }
            }
        };
        /**
         * Fired when the input focused
         */
        AutoCompleteComponent.prototype.onFocus = function (event) {
            this.hasFocus = true;
            this.getItems();
            event = this._reflectName(event);
            this.autoFocus.emit(event);
            this.focus.emit(event);
        };
        /**
         * Fired when the input focused
         */
        AutoCompleteComponent.prototype.onBlur = function (event) {
            this.hasFocus = false;
            event = this._reflectName(event);
            this.autoBlur.emit(event);
            this.blur.emit(event);
        };
        AutoCompleteComponent.prototype._reflectName = function (event) {
            if (typeof event.srcElement.attributes['ng-reflect-name'] === 'object') {
                event.srcElement.name = event.srcElement.attributes['ng-reflect-name'].value;
            }
            return event;
        };
        /**
         * Register onChangeCallback
         *
         * @param fn
         */
        AutoCompleteComponent.prototype.registerOnChange = function (fn) {
            this.onChangeCallback = fn;
        };
        /**
         * Register onTouchedCallback
         *
         * @param fn
         */
        AutoCompleteComponent.prototype.registerOnTouched = function (fn) {
            this.onTouchedCallback = fn;
        };
        /**
         * Remove already selected suggestions
         *
         * @param suggestions
         */
        AutoCompleteComponent.prototype.removeDuplicates = function (suggestions) {
            var selectedCount = this.selected ? this.selected.length : 0;
            var suggestionCount = suggestions.length;
            for (var i = 0; i < selectedCount; i++) {
                var selectedLabel = this.getLabel(this.selected[i]);
                for (var j = 0; j < suggestionCount; j++) {
                    var suggestedLabel = this.getLabel(suggestions[j]);
                    if (selectedLabel === suggestedLabel) {
                        suggestions.splice(j, 1);
                    }
                }
            }
            return suggestions;
        };
        AutoCompleteComponent.prototype.removeExcluded = function (suggestions) {
            var excludedCount = this.exclude.length;
            for (var i = 0; i < excludedCount; i++) {
                var excludeLabel = this.exclude[i];
                if (typeof excludeLabel === 'object') {
                    excludeLabel = this.getLabel(excludeLabel);
                }
                var suggestionCount = suggestions.length;
                for (var j = 0; j < suggestionCount; j++) {
                    var suggestedLabel = this.getLabel(suggestions[j]);
                    if (excludeLabel === suggestedLabel) {
                        suggestions.splice(j, 1);
                        break;
                    }
                }
            }
            return suggestions;
        };
        /**
         * Remove item from selected
         *
         * @param selection
         * @param notify?
         */
        AutoCompleteComponent.prototype.removeItem = function (selection, notify) {
            var count = this.selected ? this.selected.length : 0;
            for (var i = 0; i < count; i++) {
                var item = this.selected[i];
                var selectedLabel = this.getLabel(selection);
                var itemLabel = this.getLabel(item);
                if (selectedLabel === itemLabel) {
                    this.selected.splice(i, 1);
                }
            }
            notify = typeof notify === 'undefined' ? true : notify;
            if (notify) {
                this.itemRemoved.emit(selection);
                this.itemsChange.emit(this.selected);
            }
            this.modelChange.emit(this.selected);
        };
        /**
         * Select item from list
         *
         * @param selection
         **/
        AutoCompleteComponent.prototype.selectItem = function (selection) {
            this.keyword = this.getLabel(selection);
            this.formValue = this.getFormValue(selection);
            this.updateModel(this.formValue);
            if (this.hideListOnSelection) {
                this.hideItemList();
            }
            if (this.multi) {
                if (this.maxSelected === null || this.selected.length <= this.maxSelected) {
                    this.clearValue();
                    this.selected.push(selection);
                    this.itemsChange.emit(this.selected);
                }
                else {
                    return;
                }
            }
            else {
                this.selection = selection;
                this.selected = [selection];
                this.itemsChange.emit(selection);
            }
            this.itemSelected.emit(selection);
            this.modelChange.emit(this.selected);
        };
        /**
         * Set focus of searchbar
         */
        AutoCompleteComponent.prototype.setFocus = function () {
            if (this.useIonInput && this.inputElem) {
                this.inputElem.nativeElement.setFocus();
            }
            else if (this.searchbarElem) {
                this.searchbarElem.nativeElement.setFocus();
            }
        };
        /**
         * Set suggestions
         *
         * @param suggestions
         * @param show
         */
        AutoCompleteComponent.prototype.setSuggestions = function (suggestions, show) {
            if (this.removeDuplicateSuggestions) {
                suggestions = this.removeDuplicates(suggestions);
                suggestions = this.removeExcluded(suggestions);
            }
            this.suggestions = suggestions;
            if (show || typeof show === 'undefined') {
                this.showItemList();
            }
            if (this.autoFocusSuggestion) {
                if (this.suggestions.length !== 0) {
                    this.focusedOption = 0;
                }
            }
        };
        /**
         * Set current input value
         *
         * Used externally (ie don't delete)
         *
         * @param selection
         */
        AutoCompleteComponent.prototype.setValue = function (selection) {
            this.formValue = this.getFormValue(selection);
            this.keyword = this.getLabel(selection);
            return;
        };
        /**
         * Show item list
         */
        AutoCompleteComponent.prototype.showItemList = function () {
            if (this.showSuggestions === false) {
                this.showListChanged = true;
            }
            this.showSuggestions = true;
        };
        /**
         * Update the model
         */
        AutoCompleteComponent.prototype.updateModel = function (enteredText) {
            if (enteredText !== this.formValue) {
                this.formValue = enteredText;
                if (!this.multi) {
                    this.selected = null;
                }
            }
            if (this.onChangeCallback) {
                this.onChangeCallback(this.formValue);
            }
            this.modelChange.emit(this.selected);
        };
        /**
         * Write value
         *
         * @param value
         */
        AutoCompleteComponent.prototype.writeValue = function (value) {
            if (value !== this.selection) {
                this.selection = value || null;
                this.formValue = this.getFormValue(this.selection);
                this.keyword = this.getLabel(this.selection);
            }
        };
        return AutoCompleteComponent;
    }());
    AutoCompleteComponent.decorators = [
        { type: core.Component, args: [{
                    providers: [
                        {
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: AutoCompleteComponent,
                            multi: true
                        }
                    ],
                    selector: 'ion-auto-complete',
                    template: "<ng-template #defaultSelection\n             let-attrs=\"attrs\">\n    <ion-chip class=\"{{ attrs.removeButtonClasses }}\"\n              [color]=\"attrs.removeButtonColor\"\n              [outline]=\"true\">\n        <ion-icon *ngIf=\"frontIcon\"\n                  [name]=\"frontIcon\"\n                  [slot]=\"'start'\"\n                  color=\"primary\"></ion-icon>\n\n        <ion-label>{{ attrs.label }}</ion-label>\n\n        <ion-icon *ngIf=\"attrs.removeButtonIcon\"\n                  [name]=\"attrs.removeButtonIcon\"\n                  [slot]=\"attrs.removeButtonSlot\"></ion-icon>\n    </ion-chip>\n</ng-template>\n\n<div *ngIf=\"multi\">\n    <div *ngFor=\"let item of selected\"\n         class=\"selected-items\"\n         (click)=\"removeItem(item)\">\n        <ng-template [ngTemplateOutlet]=\"selectionTemplate || defaultSelection\"\n                     [ngTemplateOutletContext]=\"{\n                            attrs: {\n                              data:                item,\n                              label:               getLabel(item),\n                              removeButtonClasses: removeButtonClasses,\n                              removeButtonColor:   removeButtonColor,\n                              removeButtonIcon:    removeButtonIcon,\n                              removeButtonSlot:    removeButtonSlot\n                            }\n                         }\"></ng-template>\n    </div>\n</div>\n\n<ion-label *ngIf=\"label.length !== 0\"\n           [position]=\"labelPosition\">{{ label }}</ion-label>\n\n<ion-input #inputElem\n           [autocomplete]=\"autocomplete\"\n           [name]=\"name\"\n           (ionInput)=\"getItems($event)\"\n           (tap)=\"handleTap($event)\"\n           [(ngModel)]=\"keyword\"\n           (ngModelChange)=\"updateModel($event)\"\n           [placeholder]=\"autocompleteOptions.placeholder == null ? defaultOpts.placeholder : autocompleteOptions.placeholder\"\n           [type]=\"autocompleteOptions.type == null ? defaultOpts.type : autocompleteOptions.type\"\n           [clearOnEdit]=\"autocompleteOptions.clearOnEdit == null ? defaultOpts.clearOnEdit : autocompleteOptions.clearOnEdit\"\n           [clearInput]=\"autocompleteOptions.clearInput == null ? defaultOpts.clearInput : autocompleteOptions.clearInput\"\n           [color]=\"autocompleteOptions.color == null ? null : autocompleteOptions.color\"\n           [mode]=\"autocompleteOptions.mode == null ? defaultOpts.mode : autocompleteOptions.mode\"\n           [disabled]=\"disabled || (this.maxSelected !== null && this.selected.length >= this.maxSelected)\"\n           [ngClass]=\"{ 'hidden': !useIonInput, 'loading': isLoading }\"\n           [ngStyle]=\"styles.searchbar\"\n           (keydown.tab)=\"handleTabOut($event)\"\n           (keydown.shift.tab)=\"hideItemList()\"\n           (keyup.arrowDown)=\"highlightItem(-1)\"\n           (keyup.arrowUp)=\"highlightItem(1)\"\n           (keyup.enter)=\"handleSelectTap($event, suggestions[focusedOption])\"\n           (keyup.escape)=\"hideItemList()\"\n           (ionFocus)=\"onFocus($event)\"\n           (ionBlur)=\"onBlur($event)\"></ion-input>\n\n<ion-searchbar #searchbarElem\n               [autocomplete]=\"autocomplete\"\n               [name]=\"name\"\n               [animated]=\"autocompleteOptions.animated == null ? defaultOpts.animated : autocompleteOptions.animated\"\n               (ionInput)=\"getItems($event)\"\n               (tap)=\"handleTap($event)\"\n               [(ngModel)]=\"keyword\"\n               (ngModelChange)=\"updateModel($event)\"\n               [cancelButtonIcon]=\"autocompleteOptions.cancelButtonIcon == null ? defaultOpts.cancelButtonIcon : autocompleteOptions.cancelButtonIcon\"\n               [cancelButtonText]=\"autocompleteOptions.cancelButtonText == null ? defaultOpts.cancelButtonText : autocompleteOptions.cancelButtonText\"\n               [clearIcon]=\"autocompleteOptions.clearIcon == null ? defaultOpts.clearIcon : autocompleteOptions.clearIcon\"\n               [color]=\"autocompleteOptions.color == null ? null : autocompleteOptions.color\"\n               [showCancelButton]=\"autocompleteOptions.showCancelButton == null ?\n                                        (defaultOpts.showCancelButton ? 'always' : 'never') :\n                                        (autocompleteOptions.showCancelButton ? 'always' : 'never')\"\n               [debounce]=\"autocompleteOptions.debounce == null ? defaultOpts.debounce : autocompleteOptions.debounce\"\n               [placeholder]=\"autocompleteOptions.placeholder == null ? defaultOpts.placeholder : autocompleteOptions.placeholder\"\n               [autocorrect]=\"autocompleteOptions.autocorrect == null ? defaultOpts.autocorrect : autocompleteOptions.autocorrect\"\n               [mode]=\"autocompleteOptions.mode == null ? defaultOpts.mode : autocompleteOptions.mode\"\n               [searchIcon]=\"autocompleteOptions.searchIcon == null ? defaultOpts.searchIcon : autocompleteOptions.searchIcon\"\n               [spellcheck]=\"autocompleteOptions.spellcheck == null ? defaultOpts.spellcheck : autocompleteOptions.spellcheck\"\n               [type]=\"autocompleteOptions.type == null ? defaultOpts.type : autocompleteOptions.type\"\n               [ngClass]=\"{ 'hidden': useIonInput, 'loading': isLoading, 'disabled': disabled || (this.maxSelected !== null && this.selected.length >= this.maxSelected) }\"\n               [ngStyle]=\"styles.searchbar\"\n               (keydown.tab)=\"handleTabOut($event)\"\n               (keydown.shift.tab)=\"hideItemList()\"\n               (keyup.arrowDown)=\"highlightItem(-1)\"\n               (keyup.arrowUp)=\"highlightItem(1)\"\n               (keyup.enter)=\"handleSelectTap($event, suggestions[focusedOption])\"\n               (keyup.escape)=\"hideItemList()\"\n               (ionClear)=\"clickClear()\"\n               (ionFocus)=\"onFocus($event)\"\n               (ionBlur)=\"onBlur($event)\"></ion-searchbar>\n\n<ng-template #defaultTemplate\n             let-attrs=\"attrs\">\n    <span [innerHTML]='attrs.label | boldprefix:attrs.keyword'></span>\n</ng-template>\n\n<ng-template #defaultEmptyTemplate\n             let-attrs=\"attrs\"\n             class=\"ion-text-center\">\n    {{ autocompleteOptions.noItems }}\n</ng-template>\n\n<ng-template [ngTemplateOutlet]=\"listTemplate || defaultList\"\n             [ngTemplateOutletContext]=\"{\n                        attrs: {\n                            data:            suggestions,\n                            keyword:         keyword,\n                            maxResults:      maxResults,\n                            maxSelected:     maxSelected,\n                            selected:        selected,\n                            showSuggestions: showSuggestions\n                          }\n                        }\"></ng-template>\n\n<ng-template #defaultList\n             let-attrs=\"attrs\">\n    <ul *ngIf=\"!(disabled || (attrs.maxSelected !== null && attrs.selected.length >= attrs.maxSelected)) && attrs.data.length > 0 && attrs.showSuggestions\"\n        #itemList\n        [ngStyle]=\"listStyles()\">\n        <li *ngFor=\"let suggestion of attrs.data| slice:0 : attrs.maxResults; let index = index\"\n            [ngClass]=\"{ 'focus': focusedOption === index }\"\n            [ngStyle]=\"styles.listItem\"\n            (mouseenter)=\"focusedOption = index\"\n            (click)=\"handleSelectTap($event, suggestion)\"\n            (tap)=\"handleSelectTap($event, suggestion)\">\n            <ng-template [ngTemplateOutlet]=\"template || defaultTemplate\"\n                         [ngTemplateOutletContext]=\"{\n                            attrs:{\n                              data:               suggestion,\n                              label:              getLabel(suggestion),\n                              keyword:            keyword,\n                              formValue:          getFormValue(suggestion),\n                              labelAttribute:     getLabel(suggestion),\n                              formValueAttribute: getFormValue(suggestion)\n                            }\n                         }\"></ng-template>\n        </li>\n    </ul>\n\n    <ul *ngIf=\"!isLoading && suggestions.length === 0 && showSuggestions\"\n        [ngStyle]=\"listStyles()\">\n        <li [ngStyle]=\"styles.listItem\">\n            <ng-template [ngTemplateOutlet]=\"emptyTemplate || defaultEmptyTemplate\"\n                         [ngTemplateOutletContext]=\"{\n                        attrs:{\n                          keyword: keyword\n                        }\n                     }\"></ng-template>\n        </li>\n    </ul>\n</ng-template>\n",
                    styles: ["ion-auto-complete{overflow:hidden!important;width:90vw;display:inline-block}ion-auto-complete ion-searchbar{padding:1px!important}ion-auto-complete .disabled input.searchbar-input{pointer-events:none;cursor:default}ion-auto-complete ul{position:absolute;width:90vw;margin-top:0;background:#fff;list-style-type:none;padding:0;left:16px;z-index:999;box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 3px 1px -2px rgba(0,0,0,.2),0 1px 5px 0 rgba(0,0,0,.12)}ion-auto-complete ul li{padding:15px;border-bottom:1px solid #c1c1c1}ion-auto-complete ul li span{pointer-events:none}ion-auto-complete ul ion-auto-complete-item{height:40px;width:100%}ion-auto-complete ul li:last-child{border:none}ion-auto-complete ul li.focus,ion-auto-complete ul li:focus{cursor:pointer;background:#f1f1f1}ion-auto-complete .hidden{display:none}ion-auto-complete .loading input.searchbar-input{background:#fff url(/assets/loading.gif) no-repeat right 4px center;background-size:25px 25px}ion-auto-complete .searchbar-clear-button.sc-ion-searchbar-md{right:34px}ion-auto-complete .selected-items{float:left}"]
                },] }
    ];
    AutoCompleteComponent.ctorParameters = function () { return []; };
    AutoCompleteComponent.propDecorators = {
        alwaysShowList: [{ type: core.Input }],
        autocomplete: [{ type: core.Input }],
        autoFocusSuggestion: [{ type: core.Input }],
        clearInvalidInput: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        emptyTemplate: [{ type: core.Input }],
        exclude: [{ type: core.Input }],
        frontIcon: [{ type: core.Input }],
        hideListOnSelection: [{ type: core.Input }],
        keyword: [{ type: core.Input }],
        label: [{ type: core.Input }],
        labelPosition: [{ type: core.Input }],
        listTemplate: [{ type: core.Input }],
        location: [{ type: core.Input }],
        maxResults: [{ type: core.Input }],
        maxSelected: [{ type: core.Input }],
        multi: [{ type: core.Input }],
        name: [{ type: core.Input }],
        provider: [{ type: core.Input }],
        removeButtonClasses: [{ type: core.Input }],
        removeButtonColor: [{ type: core.Input }],
        removeButtonIcon: [{ type: core.Input }],
        removeButtonSlot: [{ type: core.Input }],
        removeDuplicateSuggestions: [{ type: core.Input }],
        selectionTemplate: [{ type: core.Input }],
        selectOnTabOut: [{ type: core.Input }],
        showResultsFirst: [{ type: core.Input }],
        styles: [{ type: core.Input }],
        template: [{ type: core.Input }],
        useIonInput: [{ type: core.Input }],
        autoFocus: [{ type: core.Output }],
        autoBlur: [{ type: core.Output }],
        blur: [{ type: core.Output }],
        focus: [{ type: core.Output }],
        ionAutoInput: [{ type: core.Output }],
        itemsChange: [{ type: core.Output }],
        itemsCleared: [{ type: core.Output }],
        itemsHidden: [{ type: core.Output }],
        itemRemoved: [{ type: core.Output }],
        itemSelected: [{ type: core.Output }],
        itemsShown: [{ type: core.Output }],
        modelChange: [{ type: core.Output }],
        searchbarElem: [{ type: core.ViewChild, args: ['searchbarElem',
                    {
                        read: core.ElementRef
                    },] }],
        inputElem: [{ type: core.ViewChild, args: ['inputElem',
                    {
                        read: core.ElementRef
                    },] }],
        itemList: [{ type: core.ViewChild, args: ['itemList',
                    {
                        read: core.ElementRef
                    },] }],
        dataProvider: [{ type: core.Input }],
        eager: [{ type: core.Input }],
        options: [{ type: core.Input }],
        model: [{ type: core.Input }],
        showList: [{ type: core.Input }],
        documentClickHandler: [{ type: core.HostListener, args: ['document:click', ['$event'],] }]
    };

    /**
     * Bolds the beginning of the matching string in the item
     */
    var BoldPrefix = /** @class */ (function () {
        function BoldPrefix() {
        }
        BoldPrefix.prototype.transform = function (value, keyword) {
            if (!keyword) {
                return value;
            }
            var escaped_keyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            return value.replace(new RegExp(escaped_keyword, 'gi'), function (str) {
                return str.bold();
            });
        };
        return BoldPrefix;
    }());
    BoldPrefix.decorators = [
        { type: core.Pipe, args: [{
                    name: 'boldprefix'
                },] },
        { type: core.Injectable }
    ];

    var AutoCompleteModule = /** @class */ (function () {
        function AutoCompleteModule() {
        }
        AutoCompleteModule.forRoot = function () {
            return {
                ngModule: AutoCompleteModule,
                providers: []
            };
        };
        return AutoCompleteModule;
    }());
    AutoCompleteModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        AutoCompleteComponent,
                        BoldPrefix
                    ],
                    exports: [
                        AutoCompleteComponent,
                        BoldPrefix
                    ],
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        angular.IonicModule
                    ]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AutoCompleteComponent = AutoCompleteComponent;
    exports.AutoCompleteModule = AutoCompleteModule;
    exports.AutoCompleteOptions = AutoCompleteOptions;
    exports.AutoCompleteStyles = AutoCompleteStyles;
    exports.BoldPrefix = BoldPrefix;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ionic4-auto-complete.umd.js.map
